<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GokGames - En ƒ∞yi Oyunlar</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem 0;
            backdrop-filter: blur(10px);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            border-bottom: 2px solid #fff3;
        }

        .header h1 {
            text-align: center;
            font-size: 2.5rem;
            color: #fff;
            text-shadow: 0 0 20px #fff;
            letter-spacing: 2px;
        }

        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .nav-btn {
            padding: 0.5rem 1rem;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .main-content {
            margin-top: 140px;
            min-height: calc(100vh - 140px);
            padding: 2rem;
        }

        .home-screen {
            display: block;
            text-align: center;
        }

        .welcome-text {
            font-size: 1.8rem;
            margin-bottom: 3rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: #fff;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .game-card h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #fff;
        }

        .game-card p {
            opacity: 0.9;
            line-height: 1.6;
        }

        .game-screen {
            display: none;
            text-align: center;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 2rem;
            margin: 0 auto;
            max-width: 800px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .control-btn {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .control-btn.muted {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .score-display {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .game-canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        }

        .game-info {
            margin-top: 1rem;
            color: #ccc;
        }

        .message {
            font-size: 2rem;
            margin: 1rem 0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .win-message {
            color: #4ecdc4;
        }

        .lose-message {
            color: #e74c3c;
        }

        @media (max-width: 768px) {
            .games-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .game-card {
                padding: 1.5rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÆ GokGames</h1>
        <div class="nav-buttons">
            <button class="nav-btn" onclick="showHome()">üè† Ana Sayfa</button>
            <button class="nav-btn" onclick="showGame('current')" id="currentGameBtn" style="display: none;">üéØ Oyuna D√∂n</button>
        </div>
    </div>

    <div class="main-content">
        <!-- Ana Sayfa -->
        <div id="home" class="home-screen">
            <div class="welcome-text">
                <h2>üéÆ En ƒ∞yi Oyunlar Burada! üéÆ</h2>
                <p>Klasik arcade oyunlarƒ±nƒ± oyna, eƒülen ve rekoru kƒ±r!</p>
            </div>
            
            <div class="games-grid">
                <div class="game-card" onclick="showGame('snake')">
                    <h3>üêç Snake</h3>
                    <p>Yƒ±lanƒ±n b√ºy√ºyerek elma toplama oyunu. Duvara √ßarpma!</p>
                </div>
                
                <div class="game-card" onclick="showGame('pong')">
                    <h3>üèì Pong</h3>
                    <p>ƒ∞ki raketli klasik top oyunu. Bilgisayara kar≈üƒ± oyna!</p>
                </div>
                
                <div class="game-card" onclick="showGame('tetris')">
                    <h3>üß© Tetris</h3>
                    <p>Klasik blok d√º≈ü√ºrme oyunu. Bloklarƒ± d√∂nd√ºr√ºp sƒ±rala!</p>
                </div>
                
                <div class="game-card" onclick="showGame('tictactoe')">
                    <h3>‚ùå Tic-Tac-Toe</h3>
                    <p>3x3 X-O oyunu. √ú√ß tane yan yana getirmeye √ßalƒ±≈ü!</p>
                </div>
                
                <div class="game-card" onclick="showGame('breakout')">
                    <h3>üß± Breakout</h3>
                    <p>Topla tuƒüla kƒ±rma oyunu. T√ºm tuƒülalarƒ± yok et!</p>
                </div>
                
                <div class="game-card" onclick="showGame('2048')">
                    <h3>üî¢ 2048</h3>
                    <p>Sayƒ± birle≈ütirme puzzle oyunu. 2048'e ula≈ümaya √ßalƒ±≈ü!</p>
                </div>
                
                <div class="game-card" onclick="showGame('flappybird')">
                    <h3>üê¶ Flappy Bird</h3>
                    <p>Engellerden ka√ßƒ±nma oyunu. Olabildiƒüince uzaƒüa git!</p>
                </div>
                
                <div class="game-card" onclick="showGame('memory')">
                    <h3>üß† Memory</h3>
                    <p>E≈ü kartlarƒ± bulma oyunu. Hafƒ±zanƒ± test et!</p>
                </div>
                
                <div class="game-card" onclick="showGame('pacman')">
                    <h3>üëª Pac-Man</h3>
                    <p>Labirent oyunu. Noktalarƒ± topla, hayaletlerden ka√ß!</p>
                </div>
                
                <div class="game-card" onclick="showGame('endlessrunner')">
                    <h3>üèÉ Endless Runner</h3>
                    <p>Ko≈ü, zƒ±pla, engellerden ka√ß! Ne kadar uzaƒüa gidebilirsin?</p>
                </div>
            </div>
        </div>

        <!-- Oyun Ekranlarƒ± -->
        <div id="gameScreen" class="game-screen">
            <div class="game-container">
                <div class="game-controls">
                    <button class="control-btn" onclick="toggleSound()" id="soundBtn">üîä Ses A√ßƒ±k</button>
                    <button class="control-btn" onclick="newGame()" id="newGameBtn">üéÆ Yeni Oyun</button>
                </div>
                
                <div class="score-display" id="scoreDisplay">Puan: 0</div>
                
                <canvas id="gameCanvas" class="game-canvas" width="600" height="400"></canvas>
                
                <div class="game-info" id="gameInfo">
                    Ok tu≈ülarƒ± ile oyna
                </div>
                
                <div id="gameMessage" class="message" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        // Global deƒüi≈ükenler
        let currentGame = null;
        let gameState = {};
        let soundEnabled = true;
        let animationId = null;
        let gameInterval = null;
        let audioContext = null;
        
        // Ses sistemi
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playSound(frequency, duration, type = 'sine') {
            if (!soundEnabled) return;
            initAudio();
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch(e) {
                // Ses hatasƒ± varsa sessizce ge√ß
            }
        }

        // UI Fonksiyonlarƒ±
        function showHome() {
            document.getElementById('home').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('currentGameBtn').style.display = 'none';
            cleanupGame();
        }

        function showGame(gameName) {
            if (gameName === 'current' && currentGame) {
                gameName = currentGame;
            }
            
            document.getElementById('home').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('currentGameBtn').style.display = 'inline-block';
            
            cleanupGame();
            currentGame = gameName;
            initGame(gameName);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('soundBtn');
            if (soundEnabled) {
                btn.textContent = 'üîä Ses A√ßƒ±k';
                btn.classList.remove('muted');
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } else {
                btn.textContent = 'üîá Ses Kapalƒ±';
                btn.classList.add('muted');
            }
        }

        function newGame() {
            if (currentGame) {
                cleanupGame();
                initGame(currentGame);
            }
        }

        function cleanupGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            document.getElementById('gameMessage').style.display = 'none';
        }

        function updateScore(score) {
            document.getElementById('scoreDisplay').textContent = `Puan: ${score}`;
        }

        function showMessage(text, type = 'info') {
            const messageEl = document.getElementById('gameMessage');
            messageEl.textContent = text;
            messageEl.className = `message ${type}`;
            messageEl.style.display = 'block';
            
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 3000);
        }

        // Oyun ba≈ülatma sistemi
        function initGame(gameName) {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const infoEl = document.getElementById('gameInfo');
            
            canvas.width = 600;
            canvas.height = 400;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            switch(gameName) {
                case 'snake':
                    infoEl.textContent = 'Ok tu≈ülarƒ± ile yƒ±lanƒ± kontrol et - Hareket etmek i√ßin ok tu≈üuna bas!';
                    initSnake(canvas, ctx);
                    break;
                case 'pong':
                    infoEl.textContent = 'Ok tu≈ülarƒ± ile raketi kontrol et';
                    initPong(canvas, ctx);
                    break;
                case 'tetris':
                    infoEl.textContent = 'A/S: D√∂nd√ºr, Ok tu≈ülarƒ±: Hareket';
                    initTetris(canvas, ctx);
                    break;
                case 'tictactoe':
                    infoEl.textContent = 'Fareyle tƒ±kla ve oyna';
                    initTicTacToe(canvas, ctx);
                    break;
                case 'breakout':
                    infoEl.textContent = 'Sol/Saƒü ok tu≈ülarƒ± ile raketi kontrol et';
                    initBreakout(canvas, ctx);
                    break;
                case '2048':
                    infoEl.textContent = 'Ok tu≈ülarƒ± ile karolarƒ± hareket ettir';
                    init2048(canvas, ctx);
                    break;
                case 'flappybird':
                    infoEl.textContent = 'Bo≈üluk tu≈üu ile ku≈üu zƒ±plat';
                    initFlappyBird(canvas, ctx);
                    break;
                case 'memory':
                    infoEl.textContent = 'Kartlarƒ± tƒ±klayarak e≈ülerini bul';
                    initMemory(canvas, ctx);
                    break;
                case 'pacman':
                    infoEl.textContent = 'Ok tu≈ülarƒ± ile Pac-Man\'i kontrol et';
                    initPacman(canvas, ctx);
                    break;
                case 'endlessrunner':
                    infoEl.textContent = 'Bo≈üluk: Zƒ±pla, Engellerden ka√ß!';
                    initEndlessRunner(canvas, ctx);
                    break;
            }
            
            updateScore(0);
        }

        // OYUN FONKSƒ∞YONLARI (Kƒ±sa versiyonlar)
        
        // Snake Oyunu
        function initSnake(canvas, ctx) {
            const GRID_SIZE = 20;
            const GRID_WIDTH = canvas.width / GRID_SIZE;
            const GRID_HEIGHT = canvas.height / GRID_SIZE;
            
            gameState = {
                snake: [{x: 10, y: 10}],
                food: {x: 15, y: 15},
                dx: 0, dy: 0,
                score: 0,
                gameOver: false,
                started: false
            };
            
            function generateFood() {
                gameState.food = {
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT)
                };
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Yƒ±lan
                gameState.snake.forEach((segment, index) => {
                    ctx.fillStyle = index === 0 ? '#2E7D32' : '#4CAF50';
                    ctx.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE - 2, GRID_SIZE - 2);
                });
                
                // Yiyecek
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(gameState.food.x * GRID_SIZE, gameState.food.y * GRID_SIZE, GRID_SIZE - 2, GRID_SIZE - 2);
                
                if (!gameState.started) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Ba≈ülamak i√ßin ok tu≈üuna bas!', canvas.width/2, canvas.height/2);
                }
            }
            
            function update() {
                if (gameState.gameOver || !gameState.started) return;
                
                const head = {x: gameState.snake[0].x + gameState.dx, y: gameState.snake[0].y + gameState.dy};
                
                if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
                    gameState.gameOver = true;
                    showMessage('Oyun Bitti!', 'lose-message');
                    playSound(200, 0.5);
                    return;
                }
                
                if (gameState.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    gameState.gameOver = true;
                    showMessage('Oyun Bitti!', 'lose-message');
                    playSound(200, 0.5);
                    return;
                }
                
                gameState.snake.unshift(head);
                
                if (head.x === gameState.food.x && head.y === gameState.food.y) {
                    gameState.score += 10;
                    updateScore(gameState.score);
                    generateFood();
                    playSound(600, 0.1);
                } else {
                    gameState.snake.pop();
                }
                
                draw();
            }
            
            document.addEventListener('keydown', (e) => {
                if (gameState.gameOver) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (gameState.dy === 0) { gameState.dx = 0; gameState.dy = -1; gameState.started = true; }
                        break;
                    case 'ArrowDown':
                        if (gameState.dy === 0) { gameState.dx = 0; gameState.dy = 1; gameState.started = true; }
                        break;
                    case 'ArrowLeft':
                        if (gameState.dx === 0) { gameState.dx = -1; gameState.dy = 0; gameState.started = true; }
                        break;
                    case 'ArrowRight':
                        if (gameState.dx === 0) { gameState.dx = 1; gameState.dy = 0; gameState.started = true; }
                        break;
                }
            });
            
            generateFood();
            draw();
            gameInterval = setInterval(update, 150);
        }

        // Basit Pong
        function initPong(canvas, ctx) {
            gameState = {
                paddle: { x: 10, y: canvas.height / 2 - 40, width: 10, height: 80 },
                aiPaddle: { x: canvas.width - 20, y: canvas.height / 2 - 40, width: 10, height: 80 },
                ball: { x: canvas.width / 2, y: canvas.height / 2, dx: 5, dy: 3, radius: 8 },
                score: 0, aiScore: 0, keys: {}
            };
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.fillRect(gameState.paddle.x, gameState.paddle.y, gameState.paddle.width, gameState.paddle.height);
                ctx.fillRect(gameState.aiPaddle.x, gameState.aiPaddle.y, gameState.aiPaddle.width, gameState.aiPaddle.height);
                ctx.beginPath();
                ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            function update() {
                if (gameState.keys['ArrowUp'] && gameState.paddle.y > 0) gameState.paddle.y -= 7;
                if (gameState.keys['ArrowDown'] && gameState.paddle.y < canvas.height - gameState.paddle.height) gameState.paddle.y += 7;
                
                const aiCenter = gameState.aiPaddle.y + gameState.aiPaddle.height / 2;
                if (aiCenter < gameState.ball.y - 35) gameState.aiPaddle.y += 4;
                else if (aiCenter > gameState.ball.y + 35) gameState.aiPaddle.y -= 4;
                
                gameState.ball.x += gameState.ball.dx;
                gameState.ball.y += gameState.ball.dy;
                
                if (gameState.ball.y <= gameState.ball.radius || gameState.ball.y >= canvas.height - gameState.ball.radius) {
                    gameState.ball.dy = -gameState.ball.dy;
                    playSound(400, 0.1);
                }
                
                if (gameState.ball.x < 0) {
                    gameState.aiScore++;
                    resetBall();
                }
                if (gameState.ball.x > canvas.width) {
                    gameState.score++;
                    updateScore(gameState.score);
                    resetBall();
                }
                
                draw();
            }
            
            function resetBall() {
                gameState.ball.x = canvas.width / 2;
                gameState.ball.y = canvas.height / 2;
                gameState.ball.dx = -gameState.ball.dx;
            }
            
            document.addEventListener('keydown', (e) => { gameState.keys[e.key] = true; });
            document.addEventListener('keyup', (e) => { gameState.keys[e.key] = false; });
            
            draw();
            gameInterval = setInterval(update, 16);
        }

        // Diƒüer oyunlar i√ßin basit placeholderlar
        function initTetris(canvas, ctx) {
            const COLS = 10, ROWS = 20, BLOCK_SIZE = 20;
            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;
            
            gameState = {
                grid: Array(ROWS).fill().map(() => Array(COLS).fill(0)),
                currentPiece: null,
                score: 0,
                gameOver: false,
                dropTime: 0
            };
            
            const pieces = [
                { shape: [[1,1,1,1]], color: '#00ffff' },
                { shape: [[1,1],[1,1]], color: '#ffff00' },
                { shape: [[0,1,0],[1,1,1]], color: '#800080' }
            ];
            
            function newPiece() {
                const piece = pieces[Math.floor(Math.random() * pieces.length)];
                return { shape: piece.shape, x: 4, y: 0, color: piece.color };
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (gameState.grid[y][x]) {
                            ctx.fillStyle = gameState.grid[y][x];
                            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    }
                }
                
                if (gameState.currentPiece) {
                    ctx.fillStyle = gameState.currentPiece.color;
                    gameState.currentPiece.shape.forEach((row, y) => {
                        row.forEach((cell, x) => {
                            if (cell) {
                                ctx.fillRect((gameState.currentPiece.x + x) * BLOCK_SIZE, 
                                           (gameState.currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                            }
                        });
                    });
                }
            }
            
            function update() {
                if (gameState.gameOver) return;
                gameState.dropTime++;
                
                if (!gameState.currentPiece) gameState.currentPiece = newPiece();
                
                if (gameState.dropTime > 30) {
                    gameState.currentPiece.y++;
                    gameState.dropTime = 0;
                    
                    if (gameState.currentPiece.y > ROWS - 2) {
                        gameState.currentPiece = newPiece();
                        gameState.score += 10;
                        updateScore(gameState.score);
                    }
                }
                draw();
            }
            
            document.addEventListener('keydown', (e) => {
                if (!gameState.currentPiece) return;
                switch(e.key) {
                    case 'ArrowLeft': gameState.currentPiece.x = Math.max(0, gameState.currentPiece.x - 1); break;
                    case 'ArrowRight': gameState.currentPiece.x = Math.min(COLS - 2, gameState.currentPiece.x + 1); break;
                    case 'ArrowDown': gameState.currentPiece.y++; break;
                }
                draw();
            });
            
            gameInterval = setInterval(update, 100);
        }

        function initTicTacToe(canvas, ctx) {
            gameState = { board: Array(9).fill(''), currentPlayer: 'X', gameOver: false };
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                
                for (let i = 1; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * canvas.width / 3, 0);
                    ctx.lineTo(i * canvas.width / 3, canvas.height);
                    ctx.moveTo(0, i * canvas.height / 3);
                    ctx.lineTo(canvas.width, i * canvas.height / 3);
                    ctx.stroke();
                }
                
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 9; i++) {
                    if (gameState.board[i]) {
                        const x = (i % 3) * (canvas.width / 3) + (canvas.width / 6);
                        const y = Math.floor(i / 3) * (canvas.height / 3) + (canvas.height / 1.8);
                        ctx.fillStyle = gameState.board[i] === 'X' ? '#ff6b6b' : '#4ecdc4';
                        ctx.fillText(gameState.board[i], x, y);
                    }
                }
            }
            
            function makeMove(index) {
                if (gameState.board[index] || gameState.gameOver) return;
                gameState.board[index] = gameState.currentPlayer;
                gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
                gameState.score += 5;
                updateScore(gameState.score);
                playSound(600, 0.1);
                draw();
            }
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const cellX = Math.floor(x / (canvas.width / 3));
                const cellY = Math.floor(y / (canvas.height / 3));
                makeMove(cellY * 3 + cellX);
            });
            
            draw();
        }

        function initBreakout(canvas, ctx) {
            gameState = {
                paddle: { x: canvas.width / 2 - 50, y: canvas.height - 30, width: 100, height: 10 },
                ball: { x: canvas.width / 2, y: canvas.height - 50, dx: 5, dy: -5, radius: 8 },
                bricks: [], score: 0, keys: {}
            };
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 10; col++) {
                    gameState.bricks.push({
                        x: col * 60 + 30, y: row * 30 + 50,
                        width: 50, height: 20, destroyed: false
                    });
                }
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                gameState.bricks.forEach(brick => {
                    if (!brick.destroyed) {
                        ctx.fillStyle = '#ff6b6b';
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    }
                });
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(gameState.paddle.x, gameState.paddle.y, gameState.paddle.width, gameState.paddle.height);
                ctx.beginPath();
                ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            function update() {
                if (gameState.keys['ArrowLeft'] && gameState.paddle.x > 0) gameState.paddle.x -= 8;
                if (gameState.keys['ArrowRight'] && gameState.paddle.x < canvas.width - gameState.paddle.width) gameState.paddle.x += 8;
                
                gameState.ball.x += gameState.ball.dx;
                gameState.ball.y += gameState.ball.dy;
                
                if (gameState.ball.x <= gameState.ball.radius || gameState.ball.x >= canvas.width - gameState.ball.radius) gameState.ball.dx = -gameState.ball.dx;
                if (gameState.ball.y <= gameState.ball.radius) gameState.ball.dy = -gameState.ball.dy;
                
                if (gameState.ball.y > canvas.height) {
                    showMessage('Oyun Bitti!', 'lose-message');
                    clearInterval(gameInterval);
                }
                
                gameState.bricks.forEach(brick => {
                    if (!brick.destroyed && gameState.ball.x >= brick.x && gameState.ball.x <= brick.x + brick.width &&
                        gameState.ball.y >= brick.y && gameState.ball.y <= brick.y + brick.height) {
                        brick.destroyed = true;
                        gameState.ball.dy = -gameState.ball.dy;
                        gameState.score += 10;
                        updateScore(gameState.score);
                        playSound(800, 0.1);
                    }
                });
                
                draw();
            }
            
            document.addEventListener('keydown', (e) => { gameState.keys[e.key] = true; });
            document.addEventListener('keyup', (e) => { gameState.keys[e.key] = false; });
            
            draw();
            gameInterval = setInterval(update, 16);
        }

        function init2048(canvas, ctx) {
            const GRID_SIZE = 4;
            canvas.width = 480;
            canvas.height = 480;
            
            gameState = {
                grid: Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)),
                score: 0
            };
            
            function addTile() {
                const empty = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (gameState.grid[y][x] === 0) empty.push({x, y});
                    }
                }
                if (empty.length > 0) {
                    const cell = empty[Math.floor(Math.random() * empty.length)];
                    gameState.grid[cell.y][cell.x] = Math.random() < 0.9 ? 2 : 4;
                }
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#bbada0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const value = gameState.grid[y][x];
                        const cellX = x * 120 + 10;
                        const cellY = y * 120 + 10;
                        
                        ctx.fillStyle = value ? '#eee4da' : '#cdc1b4';
                        ctx.fillRect(cellX, cellY, 100, 100);
                        
                        if (value > 0) {
                            ctx.fillStyle = '#776e65';
                            ctx.font = '32px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(value, cellX + 50, cellY + 60);
                        }
                    }
                }
            }
            
            function move(direction) {
                let moved = false;
                // Basit hareket mantƒ±ƒüƒ±
                if (direction === 'left') {
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 1; x < GRID_SIZE; x++) {
                            if (gameState.grid[y][x] && !gameState.grid[y][x-1]) {
                                gameState.grid[y][x-1] = gameState.grid[y][x];
                                gameState.grid[y][x] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                if (moved) {
                    addTile();
                    gameState.score += 10;
                    updateScore(gameState.score);
                    playSound(400, 0.1);
                }
                draw();
            }
            
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowLeft': move('left'); break;
                    case 'ArrowRight': move('right'); break;
                    case 'ArrowUp': move('up'); break;
                    case 'ArrowDown': move('down'); break;
                }
            });
            
            addTile();
            addTile();
            draw();
        }

        function initFlappyBird(canvas, ctx) {
            gameState = {
                bird: { x: 100, y: canvas.height / 2, dy: 0, radius: 15 },
                pipes: [], score: 0, gameOver: false
            };
            
            function createPipe() {
                const gap = 120;
                const pipeHeight = Math.random() * (canvas.height - gap - 100) + 50;
                gameState.pipes.push({
                    x: canvas.width, topHeight: pipeHeight,
                    bottomY: pipeHeight + gap, width: 50, passed: false
                });
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(gameState.bird.x, gameState.bird.y, gameState.bird.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#4caf50';
                gameState.pipes.forEach(pipe => {
                    ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                    ctx.fillRect(pipe.x, pipe.bottomY, pipe.width, canvas.height - pipe.bottomY);
                });
            }
            
            function update() {
                if (gameState.gameOver) return;
                
                gameState.bird.dy += 0.5;
                gameState.bird.y += gameState.bird.dy;
                
                gameState.pipes.forEach(pipe => {
                    pipe.x -= 3;
                    if (!pipe.passed && pipe.x + pipe.width < gameState.bird.x) {
                        pipe.passed = true;
                        gameState.score++;
                        updateScore(gameState.score);
                        playSound(600, 0.1);
                    }
                });
                
                gameState.pipes = gameState.pipes.filter(pipe => pipe.x + pipe.width > 0);
                
                if (gameState.pipes.length === 0 || gameState.pipes[gameState.pipes.length - 1].x < canvas.width - 200) {
                    createPipe();
                }
                
                if (gameState.bird.y <= 0 || gameState.bird.y >= canvas.height) {
                    gameState.gameOver = true;
                    showMessage('Oyun Bitti!', 'lose-message');
                    clearInterval(gameInterval);
                }
                
                draw();
            }
            
            document.addEventListener('keydown', (e) => {
                if (e.key === ' ') {
                    gameState.bird.dy = -8;
                    playSound(400, 0.1);
                }
            });
            
            createPipe();
            draw();
            gameInterval = setInterval(update, 16);
        }

        function initMemory(canvas, ctx) {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8', '#f7dc6f'];
            const cards = [...colors, ...colors].sort(() => Math.random() - 0.5);
            
            gameState = {
                cards: cards.map((color, index) => ({ color, flipped: false, matched: false, index })),
                flippedCards: [], score: 0
            };
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < 16; i++) {
                    const x = (i % 4) * 140 + 20;
                    const y = Math.floor(i / 4) * 90 + 20;
                    const card = gameState.cards[i];
                    
                    ctx.fillStyle = (card.flipped || card.matched) ? card.color : '#333';
                    ctx.fillRect(x, y, 120, 70);
                    ctx.strokeStyle = '#fff';
                    ctx.strokeRect(x, y, 120, 70);
                }
            }
            
            function flipCard(index) {
                if (gameState.flippedCards.length >= 2 || gameState.cards[index].flipped || gameState.cards[index].matched) return;
                
                gameState.cards[index].flipped = true;
                gameState.flippedCards.push(index);
                playSound(400, 0.1);
                
                if (gameState.flippedCards.length === 2) {
                    setTimeout(() => {
                        const [first, second] = gameState.flippedCards;
                        if (gameState.cards[first].color === gameState.cards[second].color) {
                            gameState.cards[first].matched = true;
                            gameState.cards[second].matched = true;
                            gameState.score += 10;
                            updateScore(gameState.score);
                            playSound(600, 0.2);
                        } else {
                            gameState.cards[first].flipped = false;
                            gameState.cards[second].flipped = false;
                        }
                        gameState.flippedCards = [];
                        draw();
                    }, 1000);
                }
                draw();
            }
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                for (let i = 0; i < 16; i++) {
                    const cardX = (i % 4) * 140 + 20;
                    const cardY = Math.floor(i / 4) * 90 + 20;
                    if (x >= cardX && x <= cardX + 120 && y >= cardY && y <= cardY + 70) {
                        flipCard(i);
                        break;
                    }
                }
            });
            
            draw();
        }

        function initPacman(canvas, ctx) {
            const CELL_SIZE = 20;
            const COLS = 30;
            const ROWS = 20;
            canvas.width = COLS * CELL_SIZE;
            canvas.height = ROWS * CELL_SIZE;
            
            gameState = {
                pacman: { x: 5, y: 5, direction: 'right' },
                ghosts: [{ x: 25, y: 5, direction: 'left', color: '#ff0000' }],
                dots: [], score: 0, gameOver: false
            };
            
            for (let x = 2; x < COLS - 2; x += 3) {
                for (let y = 2; y < ROWS - 2; y += 3) {
                    gameState.dots.push({ x, y });
                }
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffff00';
                gameState.dots.forEach(dot => {
                    ctx.beginPath();
                    ctx.arc(dot.x * CELL_SIZE + CELL_SIZE/2, dot.y * CELL_SIZE + CELL_SIZE/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(gameState.pacman.x * CELL_SIZE + CELL_SIZE/2, gameState.pacman.y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                
                gameState.ghosts.forEach(ghost => {
                    ctx.fillStyle = ghost.color;
                    ctx.beginPath();
                    ctx.arc(ghost.x * CELL_SIZE + CELL_SIZE/2, ghost.y * CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            function update() {
                if (gameState.gameOver) return;
                
                const directions = { 'up': {x:0,y:-1}, 'down': {x:0,y:1}, 'left': {x:-1,y:0}, 'right': {x:1,y:0} };
                const dir = directions[gameState.pacman.direction];
                const newX = gameState.pacman.x + dir.x;
                const newY = gameState.pacman.y + dir.y;
                
                if (newX > 0 && newX < COLS - 1 && newY > 0 && newY < ROWS - 1) {
                    gameState.pacman.x = newX;
                    gameState.pacman.y = newY;
                }
                
                const dotIndex = gameState.dots.findIndex(dot => dot.x === gameState.pacman.x && dot.y === gameState.pacman.y);
                if (dotIndex !== -1) {
                    gameState.dots.splice(dotIndex, 1);
                    gameState.score += 10;
                    updateScore(gameState.score);
                    playSound(600, 0.05);
                }
                
                gameState.ghosts.forEach(ghost => {
                    const ghostDir = directions[ghost.direction];
                    ghost.x += ghostDir.x;
                    ghost.y += ghostDir.y;
                    
                    if (ghost.x <= 1 || ghost.x >= COLS - 2 || ghost.y <= 1 || ghost.y >= ROWS - 2) {
                        ghost.direction = ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)];
                    }
                    
                    if (ghost.x === gameState.pacman.x && ghost.y === gameState.pacman.y) {
                        gameState.gameOver = true;
                        showMessage('Oyun Bitti!', 'lose-message');
                        clearInterval(gameInterval);
                    }
                });
                
                draw();
            }
            
            document.addEventListener('keydown', (e) => {
                if (gameState.gameOver) return;
                switch(e.key) {
                    case 'ArrowUp': gameState.pacman.direction = 'up'; break;
                    case 'ArrowDown': gameState.pacman.direction = 'down'; break;
                    case 'ArrowLeft': gameState.pacman.direction = 'left'; break;
                    case 'ArrowRight': gameState.pacman.direction = 'right'; break;
                }
            });
            
            draw();
            gameInterval = setInterval(update, 200);
        }

        function initEndlessRunner(canvas, ctx) {
            gameState = {
                player: { x: 100, y: canvas.height - 60, width: 30, height: 50, velocityY: 0, onGround: true },
                obstacles: [], score: 0, gameOver: false, speed: 3, keys: {}
            };
            
            const GROUND_Y = canvas.height - 10;
            
            function createObstacle() {
                gameState.obstacles.push({
                    x: canvas.width, y: GROUND_Y - 30, width: 20, height: 30, passed: false
                });
            }
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(0, GROUND_Y, canvas.width, 10);
                
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);
                
                ctx.fillStyle = '#8B4513';
                gameState.obstacles.forEach(obstacle => {
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
                
                ctx.fillStyle = '#000';
                ctx.font = '20px Arial';
                ctx.fillText(`Skor: ${gameState.score}`, 10, 30);
            }
            
            function update() {
                if (gameState.gameOver) return;
                
                if (gameState.keys[' '] && gameState.player.onGround) {
                    gameState.player.velocityY = -12;
                    gameState.player.onGround = false;
                    playSound(400, 0.1);
                }
                
                gameState.player.velocityY += 0.8;
                gameState.player.y += gameState.player.velocityY;
                
                if (gameState.player.y >= GROUND_Y - gameState.player.height) {
                    gameState.player.y = GROUND_Y - gameState.player.height;
                    gameState.player.velocityY = 0;
                    gameState.player.onGround = true;
                }
                
                if (Math.random() < 0.02) createObstacle();
                
                gameState.obstacles.forEach((obstacle, index) => {
                    obstacle.x -= gameState.speed;
                    
                    if (!obstacle.passed && obstacle.x + obstacle.width < gameState.player.x) {
                        obstacle.passed = true;
                        gameState.score += 10;
                        updateScore(gameState.score);
                        playSound(600, 0.1);
                    }
                    
                    if (gameState.player.x < obstacle.x + obstacle.width &&
                        gameState.player.x + gameState.player.width > obstacle.x &&
                        gameState.player.y < obstacle.y + obstacle.height &&
                        gameState.player.y + gameState.player.height > obstacle.y) {
                        gameState.gameOver = true;
                        showMessage('Oyun Bitti!', 'lose-message');
                        clearInterval(gameInterval);
                    }
                    
                    if (obstacle.x + obstacle.width < 0) {
                        gameState.obstacles.splice(index, 1);
                    }
                });
                
                gameState.speed += 0.001;
                draw();
            }
            
            document.addEventListener('keydown', (e) => { gameState.keys[e.key] = true; });
            document.addEventListener('keyup', (e) => { gameState.keys[e.key] = false; });
            
            draw();
            gameInterval = setInterval(update, 16);
        }

        // Ba≈ülangƒ±√ß
        showHome();
    </script>
</body>
</html>
